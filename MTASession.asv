classdef MTASession < hgsetget
% MTASession(name,varargin) - Data structure to organize the analysis of neural and spatial data.
%
%   name - string: Same name as the directory of the session
%
%   varargin:
%     [preLoadedFields,mazeName,overwrite,TTLValue,xyzSampleRate,trackingMarker,spath,sampleRate]
%
%     preLoadedFields: cellArray, load saved data into Session fields
%                      (e.g. {'ufr','ang'} or {'ufr',{'lfp',65:96},'CluRes'}
%
%     mazeName:        string, 3-4 letter name of the testing arena 
%                      (e.g. 'rof' := rectangular open-field)
%
%     overwrite:       boolean, flag to overwrite saved Sessions
%
%     ignore_events:   boolean, flag to ignore events from recording system
%                                when only the xyz data is required
%
%     TTLValue:        string, used to synchronize position and electrophysiological data
%
%     xyzSampleRate:   double, sample rate of position tracking system
%
%     trackingMarker:  string, marker used for placefield calculations           
%
%     sampleRate:      double, sample rate of electrophysiological recording system
%
%---------------------------------------------------------------------------------------------------------
%   General Loading:
%     
%     Load from saved Session,
%     Session = MTASession(name);
%     
%     Create new session,
%     Session = MTASession(name,[],mazeName,overwrite,ignore_events,...
%                          TTLValue,xyzSampleRate,trackingMarker,[],sampleRate);
%
%---------------------------------------------------------------------------------------------------------
%     examples:
%       load saved session,
%         Session = MTASession('jg05-20120309',[],'rof');
%
%       load saved session with presaved variables: lfp and Place fields
%         Session = MTASession('jg05-20120309',{{'lfp',65:95},'Pfs'},'rof');
%
%       load saved session with presaved variables: marker angles and Clustering data
%         Session = MTASession('jg05-20120309',{'ang','CluRes'},'rof');
%
%       Create New Session
%         Session = MTASession('jg05-20120309',[],'rof',1,0,'0x0040',119.880135,head_front,[],32552);
%   
%---------------------------------------------------------------------------------------------------------

    properties (SetAccess = public)
        
        %path - struct: holds all paths of the constructed data tree created by MTAConfiguration.m
        path           

        %spath - struct: same as path but with Session name appended to the end
        spath

        %filebase - string: full file head in the format name.(Maze.name).trialName
        filebase       

        %name - string: name of the directory holding session information
        name           

        %trialName - string: designation of trial the full Session has the default name 'all'
        trialName      

        %Maze - MTAMaze: Object containing all maze information
        Maze           

        %Model - MTAModel: Object contianing all marker information
        Model          

        %xyz - numericArray: (time,marker,dimension) XYZ position of each marker 
        xyz 

        %xyzSegLength - numericArray: length of each XYZ segment in xyz where recording occured
        xyzSegLength   

        %xyzPeriods - numericArray: (time_segment_start,time_segment_end) XYZ segment index in xyz
        xyzPeriods     

        %syncPeriods - numericArray: (time_lfp_segment_start,time_lfp_segment_end) time in lfp sample rate where xyz recording occured
        syncPeriods    

        %sampleRate - double: Sample Rate of electrophysiological recording system
        sampleRate     

        %lfpSampleRate - double: Sample Rate of lfp signal
        lfpSampleRate  

        %trackingMarker - string: Marker name used for place field calculations
        trackingMarker = 'head_front';

        %ang - numericArray: (time,marker1,marker2,[direction,pitch,distance]) angles and distances between each marker combination
        ang = [];

        %Bhv - MTABhv: Object containing behavioral states
        Bhv

        %Fet - MTAFet: Object containing behavioral features
        Fet

        %lfp - numericArray: (time,channel) local field potential
        lfp

        %Pfs - cellArray: MTAPlaceField objects containing all information af a place field
        Pfs = {};

        %ccg - cellArray: MTAccg objects containing all information af a ccg
        ccg = {};

        %ufr - numericArray: (time,cluster) unit firing rates with lfpSampleRate
        ufr = [];      

        %nq - struct: containing information about individual units
        nq = {};

        %res - numericArray: (time_index) unit event index in sampleRate or lfpSampleRate
        res

        %clu - numericArray: (res_index) unit cluster group associated with each index of res
        clu

        %map - numericArray: (clu,electrode_clu,eletrode) mapping of unit clusters to electrode cluster and electrode
        map

        %ripples - numericArray: (time_index,ripple_power,ripple_duration) time_index in lfp sample rate
        ripples        
    end

    methods

        %% Session Constructor - Creation & Loading-----------------------------------------------------%

        function Session = MTASession(name,varargin)
            [preLoadedFields,mazeName,overwrite,TTLValue,xyzSampleRate,xyzSystem,ephySystem] = ...
             DefaultArgs(varargin,{{'xyz'},'cof',0,'0x0040',119.881035,'vicon','nlx'});
            Session.path = load('MTAPaths.mat');
            
            if isempty(name),
                Session.filebase = '';
                Session.name = '';
            elseif isa(name,'MTASession')
                prop = properties('MTASession');
                    for i = 1:length(prop)
                        Session.(prop{i})=name.(prop{i});
                    end
            else
                Session.name = name;
                Session.spath = fullfile(Session.path.data,Session.name);
                Session.trialName = 'all';
                Session.Maze = MTAMaze(mazeName);
                Session.filebase = [Session.name '.' Session.Maze.name '.' Session.trialName];
                if exist(fullfile(Session.spath, [Session.filebase, '.mat']),'file')&&~overwrite
                    Session = Session.load();
                    Session = Session.updatePaths();
                elseif overwrite
                    warning(['Overwriting Session: ' fullfile(Session.spath, [Session.filebase, '.mat'])])
                    Session.create(xyzSampleRate,TTLValue,xyzSystem,ephySystem);
                else
                    warning(['Subsession with maze, ' Session.Maze.name ', does not exist: creating session']);
                    Session.create(xyzSampleRate,TTLValue,xyzSystem,ephySystem);
                end  
                
                if numel(preLoadedFields)>0;
                    for f = 1:numel(preLoadedFields),
                        field = preLoadedFields{f};
                        try
                        if iscell(field)
                            Session.(field{1}).load(field(2:end))
                        else
                            Session.(field).load;
                        end
                        catch
                            
                        end
                    end
                end
            end
        end

        function Session = create(Session,varargin)
            [xyzSampleRate,TTLValue,xyzSystem,ephySystem] = DefaultArgs(varargin,{[],'0x8000','vicon','nlx'});
            switch ephySystem,

              case 'nlx',
                switch xyzSystem,
                  case 'vicon',
                    Session = syncViconNlx(Session,xyzSampleRate,TTLValue);
                end

              case 'blackrock'
                warning(['Session creation routine does not exist ' ...
                         'for Blackrock, thank you and have a nice day'])

              otherwise
                switch xyzSystem,
                  case 'vicon'
                    Session = loadVicon(Session);
                end
            end
        end

        function Session = updatePaths(Session,varargin)
        %Session = updatePaths(Session)
        % Change Session.path & Session.spath to the current
        % MTAPath.mat configuration found in the matlab path.
            [propList] = DefaultArgs(varargin,{{}});
            Session.path = load('MTAPaths.mat');
            Session.spath = fullfile(Session.path.data, Session.name);
            if isempty(propList)
                return
            else
                for i = 1:numel(propList),
                    propPath = Session.(propList{i}).path;
                    fileNameStartIndex = regexp(fliplr(propPath),{'\\','\/'},'once');
                    fileNameStartIndex = fileNameStartIndex(~cellfun(@isempty,fileNameStartIndex));
                    fileNameStartIndex = length(propPath)-fileNameStartIndex+2;
                    Session.(propList{i}).updatePath(fullfile(Session.spath,propPath(fileNameStartIndex:end)));
                    Session.(propList{i}).load;
                end
            end
        end

        %%---------------------------------------------------------------------------------%




        %% Save and Load-------------------------------------------------------------------%

        function save(Session,varargin)
        %save(Session)
            save(fullfile(Session.spath, [Session.filebase '.ses.mat']),'Session','-v7.3');
        end

        function Session = load(Session,varargin)
        %Session = load(Session,varargin)
        %load the session file
            if numel(varargin)==1&&ischar(varargin{1}),
                Session.(varargin{1}).load;
            else
                load(fullfile(Session.spath, [Session.filebase '.mat']));    
            end
        end

        %%---------------------------------------------------------------------------------%
  



        %% Variables from XYZ -------------------------------------------------------------%        

        function diffMat = markerDiffMatrix(Session)
        %diffMat = markerDiffMatrix(Session)
        %create a time series where the position of every marker
        %has been substracted from one another
        %
        %Output: 
        %  diffMat - numericArray: (index,marker1,marker2,dim)
        %
            xl = length(Session.xyz);
            diffMat = zeros(xl,Session.Model.N,Session.Model.N,3);
            for i=1:Session.Model.N,
                for j=1:Session.Model.N,
                    diffMat(:,i,j,:) = Session.xyz(:,j,:)-Session.xyz(:,i,:);
                end
            end
        end

        function angles = transformOrigin(Session, origin, orientationVector, vectorTranSet)   
            %angles = transformOrigin(Session, origin, orientationVector, vectorTranSet)   
            diffMat = Session.markerDiffMatrix();
            mdvlen = size(diffMat,1);
            origin = Session.Model.gmi(origin);
            orientationVector = Session.Model.gmi(orientationVector);
            
            % Get transformation Matricies
            [rz,     rzMat, direction] = rotZAxis(squeeze(diffMat(:,origin,orientationVector,:)));
            [oriVector, ryMat, pitch ] = rotYAxis(rz);
            
            tCoordinates = [];
            roll = [];
            tCMarkers = [];
            
            % Transform other marker difference vectors
            if ~isempty(vectorTranSet),
                vecTSet = zeros(mdvlen,length(vectorTranSet),3);
                for i = 1:length(vectorTranSet),
                    rztrans = sum(rzMat.* repmat(permute(shiftdim(squeeze(diffMat(:,origin,Session.Model.gmi(vectorTranSet(i)),:)),-1),[2 1 3]),[1 3 1]),3);
                    rytrans = sum(ryMat.* repmat(permute(shiftdim(rztrans,-1),[2 1 3]),[1 3 1]),3);
                    vecTSet(:,i,:) = rytrans;
                    tCMarkers(end+1) = Session.Model.gmi(vectorTranSet(i)); %#ok<*AGROW>
                end
                % detect head roll and remove by transformation
                [tCoordinates, roll] = detectRoll(vecTSet);
            end
            angles = struct('oriVect',oriVector,'transVec',tCoordinates,'transMarkers',tCMarkers,'direction',direction,'pitch',pitch,'roll',roll);
        end
        
        
        %% Create MTADang.m
        function Session = load_ang(Session,ang)
            if isnumeric(ang)
                Session.ang = ang;
            elseif ischar(ang)
                switch ang
                    case 'load'
                        load([Session.spath Session.name '.' Session.Maze.name '.all.ang.mat'])
                        Session.ang = ang(Session.xyzPeriods(1):Session.xyzPeriods(end),:,:,:);
                        
                    case 'overwrite'
                        if ~exist([Session.spath Session.name '.' Session.Maze.name '.all.ang.mat'],'file')&&isa(Session,'MTASession')||~isempty(varargin),
                            ang = zeros(size(Session.xyz,1),Session.Model.N,Session.Model.N,5);
                            diffMat = Session.markerDiffMatrix();
                            for i=1:Session.Model.N,
                                for j=1:Session.Model.N,
                                    if i==j,
                                        continue
                                    end
                                    [rz,~,direction] = rotZAxis(squeeze(diffMat(:,i,j,:)));
                                    [ry,~,pitch ] = rotYAxis(rz);
                                    ang(:,i,j,1) = direction;
                                    ang(:,i,j,2) = pitch;
                                    ang(:,i,j,3:5) = ry;
                                end
                            end
                            if isa(Session,'MTASession')&&~isa(Session,'MTATrial'),
                                save([Session.spath Session.name '.' Session.Maze.name '.all.ang.mat'],'ang','-v7.3')
                            end
                            Session.ang = ang;
                        else
                            load([Session.spath Session.name '.' Session.Maze.name '.all.ang.mat'])
                            Session.ang = ang(Session.xyzPeriods(1):Session.xyzPeriods(end),:,:,:);
                        end
                    otherwise
                        ds = load([Session.spath ang]);
                        Session.ang = ds.ang;
                end
            end
        end


        function v = vel(Session,varargin)
        %v = vel(Session,varargin)
        %calculate the speed of marker(s)
        %[marker,dim] = DefaultArgs(varargin,{[1:Session.Model.N],[1:size(Session.xyz,3)]});
            [marker,dim] = DefaultArgs(varargin,{1:Session.Model.N, 1:size(Session.xyz,3)});
            v = sqrt(sum(diff(Session.xyz(:,marker,dim),1).^2,3));
        end            

        function a = acc(Session,varargin)
        %a = acc(Session,varargin)
        %calculate the acceleration of marker(s)
        %[marker,dim] = DefaultArgs(varargin,{[1:Session.Model.N],[1:size(Session.xyz,3)]});
            [marker,dim,padded] = DefaultArgs(varargin,{1:Session.Model.N, 1:size(Session.xyz,3),1});
            a = diff(Session.vel(marker,dim),1);
            if padded==1
                a = cat(1,a(1,:),a,a(end,:));
            end
        end

        function center_of_mass = com(Session,Model)
        %center_of_mass = com(Session,Model)
        %
        %Model - MTAModel: MTA object holding marker information
        %
        %Examples:
        %  Find the center of mass of the session model
        %    center_of_mass = Session.com(Session.Model);
        %
        %  Select a model based on a subset of markers from a larger model
        %    Model = Session.Model.rb({'head_back','head_left','head_front','head_right'});
        %    center_of_mass = Session.com(Model);
        %
            center_of_mass = mean(Session.xyz(:,Session.Model.gmi(Model.ml()),:),2);
        end

        %%---------------------------------------------------------------------------------%

        


        %% Bhv - Behavior Object Function -------------------------------------------------%

        function Session = load_Bhv(Session,mode)
        %Session = load_Bhv(Session,mode)
        %load MTABhv object
            Session.Bhv = MTABhv(Session,mode);
        end


        function [Session] = autoLabelBhv(Session,varargin)
        %[Session,Features] = autoLabelBhv(Session,label_mode)
        %automatically label various behaviors 
        %behaviors and their selection parameters
        %are defined in an xml file found in the 
        %analysis directory. An xml template can 
        %be found in the xml directory
        %
        %Expected XML Path:
        %  [Session.spath Session.filebase '.bhv.' mode '.xml']
        %
        %Example:
        %  Session = Session.autoLabelBhv();
        %
            [label_mode] = DefaultArgs(varargin,{'default'});
            if ~isempty(Session.Bhv),
                Session.Bhv.save(Session,1);
            end
            
            Session.Bhv = MTABhv(Session,label_mode,1);
            Session.Bhv.mode = label_mode;

            if strcmp(Session.Bhv.mode,'default'),
                rxml = xmltools([Session.path.data 'config/xml/bhv.' Session.Bhv.mode '.xml']);
            else
                rxml = xmltools([Session.spath Session.filebase '.bhv.' Session.Bhv.mode '.xml']);
            end

            keys = '';
            labels = {};
            method = {};
            variables = {0};
            rxml = xmltools(rxml,'get','parameters','child');

            for i = 1:length(rxml.child)
                if str2double(xmltools(rxml.child(i),'get-attrib','selected')) 
                    variables{end+1,1} = 0;
                    labels(end+1) = {rxml.child(i).tag};
                    keys = strcat(keys,xmltools(rxml.child(i),'get-attrib','key'));
                    for j = 1:length(rxml.child(i).child)
                        if str2double(xmltools(rxml.child(i).child(j),'get-attrib','selected'))
                            method(end+1) = {rxml.child(i).child(j).tag};                           
                            if isempty(rxml.child(i).child(j).child), variables{end,1}={};continue,end
                            for k = 1:length(rxml.child(i).child(j).child)
                                variables{end,k} = str2double(rxml.child(i).child(j).child(k).value);
                            end
                        end
                    end
                end
            end


            variables = variables(2:end,:);
            varind = zeros(size(variables));
            for i = 1:size(variables,1)
                for j = 1:size(variables,2)
                    varind(i,j) = ~isempty(variables{i,j});
                end

                heuristic = eval(['@' labels{1,i}]);

                if ~isempty(variables{i,1}),
                    [state] = heuristic(Session,method{1,i},variables{i,varind(i,:)==1});
                else
                    [state] = heuristic(Session,method{1,i});
                end
                Session.Bhv = Session.Bhv.addState(keys(i),labels{1,i},state);
            end

% $$$             % Quick fix remove when exclusion heuristic is writen
% $$$             hp = Session.Bhv.getState('head').state;
% $$$             rp = Session.Bhv.getState('rear').state;
% $$$             hts = zeros(size(Session.xyz,1),1);
% $$$             for i = 1:length(hp)
% $$$                 hts(hp(i,1):hp(i,2)) = 1;
% $$$             end
% $$$             hprp = IntersectRanges(hp,rp);
% $$$             hrts = zeros(size(Session.xyz,1),1);
% $$$             for i = 1:length(hprp)
% $$$                 hrts(hprp(i,1):hprp(i,2)) = 1;
% $$$             end
% $$$             hts(hrts==1)=0;
% $$$             newhp = ThreshCross(hts,0.5,60);
% $$$             for i = 1:length(Session.Bhv.States),
% $$$                 if strcmp('head',Session.Bhv.States{i}.label),
% $$$                     Session.Bhv.States{i}.state = newhp;
% $$$                 end
% $$$             end                    
% $$$             % End Quick fix


            Session.Bhv.save(Session,1);
        end

        function [stsp, stateLabel] = statePeriods(Session,states,varargin)
        %[stsp stateLabel] = statePeriods(Session,states,sampleRate)
        %creates state periods of individual states or their intersections
        %states - cellarray: individual state labels
        %         e.g. states = {'head','theta'};
        % 
        %
        %Examples:
        %  [stsp stateLabel = Session.statePeriods('theta');
        %  [stsp stateLabel = Session.statePeriods({'theta','rear'});
        %
        %Special message passing:
        %  [stsp stateLabel = Session.statePeriods({'theta',{'random_surrogate','nrhp',67,1250}});
        %  [stsp stateLabel = Session.statePeriods({'theta',{'onset','rear',0,1250}});
        %  [stsp stateLabel = Session.statePeriods({'theta',{'onset','rear',0,1250}});
            [newSampleRate] = DefaultArgs(varargin,{Session.lfpSampleRate});
            stateLabel = '';
            stsp = Session.syncPeriods;
            if isempty(states),return,end
            if ~iscell(states), states = {states}; end
            for i = 1:length(states),
                if length(states{i})>1&&iscell(states{i}),
                    %% Extra Special Options
                    switch states{i}{1}

                      case 'random_surrogate'
                        tp = Session.statePeriods(states{i}{2})+Session.syncPeriods(1,1);
                        surrogateIndex = [];
                        for j = 1:size(tp,1),
                            surrogateIndex = cat(1,surrogateIndex,[tp(j,1):tp(j,2)]');  %#ok<NBRAK>
                        end
                        rpi = randi(size(surrogateIndex,1),states{i}{3},1);
                        sts = repmat(rpi,1,2)+repmat([-states{i}{4},states{i}{4}],length(rpi),1);
                        states{i} = [states{i}{1} '_' states{i}{2}];

                      case 'onset'
                        sts = Session.Bhv.getState(states{i}{2}).state(:,1)+1;
                        sts = round((sts-1)./Session.xyzSampleRate.*Session.lfpSampleRate+Session.syncPeriods(1,1));
                        sts = repmat(sts,1,2)+repmat([states{i}{3}-states{i}{4},states{i}{3}+states{i}{4}],length(sts),1);
                        if states{i}{3}<0,
                            shiftsign = 'n';
                        else 
                            shiftsign = 'p';
                        end
                        states{i} = [states{i}{1} '_' num2str(round(states{i}{4}/Session.lfpSampleRate.*1000)) '_' ...
                            shiftsign num2str(states{i}{3}) '_' states{i}{2}];

                      case 'offset'
                        sts = Session.Bhv.getState(states{i}{2}).state(:,2)+1;
                        sts = round((sts-1)./Session.xyzSampleRate.*Session.lfpSampleRate+Session.syncPeriods(1,1));
                        sts = repmat(sts,1,2)+repmat([states{i}{3}-states{i}{4},states{i}{3}+states{i}{4}],length(sts),1);
                        if states{i}{3}<0,
                            shiftsign = 'n';
                        else 
                            shiftsign = 'p';
                        end
                        states{i} = [states{i}{1} '_' num2str(round(states{i}{4}/Session.lfpSampleRate.*1000)) '_' ...
                            shiftsign num2str(states{i}{3}) '_' states{i}{2}];
                    end

                elseif exist(fullfile(Session.spath, [Session.name '.sts.' states{i}]),'file');
                    sts = load(fullfile(Session.spath, [Session.name '.sts.' states{i}]));
                else
                    %% States in the Bhv have a fs of xyzSampleRate
                    sts = Session.Bhv.getState(states{i}).state+1;
                    sts = round((sts-1)./Session.xyzSampleRate.*Session.lfpSampleRate+Session.syncPeriods(1,1));
                end

                stsp = IntersectRanges(sts,stsp);
                
                if i>1,
                    stateLabel = [stateLabel '.' states{i}];
                else
                    stateLabel = states{i};
                end
            end
            stsp = stsp-Session.syncPeriods(1,1);
            stsp = round(stsp./Session.lfpSampleRate.*newSampleRate);
            stsp(stsp==0)=1; 
        end

        %%--------------------------------------------------------------------------------%




        %% Load NLX Related data ---------------------------------------------------------%

        function Session = load_lfp(Session,channels)
        %Session = load_lfp(Session,channels)
        %load Local Field Potential data
        %channels - int/array: desired electrode channels from which
        %                      lfp data is loaded
        %
        %Examples: 
        %  Session = Session.load_lfp(1);
        %  Session = Session.load_lfp(65:96);
        %
            Par = LoadPar(fullfile(Session.spath, [Session.name '.xml']));
            Session.lfp = LoadBinary(fullfile(Session.spath, [Session.name '.lfp']),channels,Par.nChannels,[],[],[],[Session.syncPeriods(1,1), Session.syncPeriods(end,2)])';
        end

        function Session = load_nq(Session)
        %Session = load_nq(Session)
        %load unit statistic
            ds = load(fullfile(Session.spath, [Session.name '.NeuronQuality.mat']));
            Session.nq = ds.nq;
        end

        function units = selectUnits(Session,query) %#ok<INUSL>
        %units = selectUnits(Session,query)
        %Return unit ids based on a query   
        %
        %  query: cellArray(formated msg) 
        %
        %  query example:
        % 
        %    query = {{PlaceField_walk,'maxRate',@gt,3},@or,{PlaceField_rear,'maxRate',@gt,3}}
       
            unit_status = [];
            fh_list = {};
            % If the qury is a single criteria wrap in a cell
            if ~iscell(query{1})
                query = {query};
            end
            % bul
            while numel(query)~=0,
                if iscell(query{1}),
                    obj = query{1}{1};                
                    objmeta = metaclass(obj);

                    if numel(query{1})>1,
                        prop = query{1}{2};
                        operator = query{1}{3};
                        selection_value = query{1}{4};
                    end
                else
                    obj = query{1};                
                    objmeta = metaclass(obj);
                end

                switch objmeta.Name
                  case 'MTAPlaceField'
                    % only really meant for the property max rate
                    % at the moment
                    target_prop = obj.(prop);
                    value = cellfun(@max,target_prop,'UniformOutput',false);
                    value(cellfun(@isempty,value))={[0]};
                    value = cell2mat(value);                    
                    unit_status = cat(2,unit_status,operator(value,selection_value));
                  case 'struct'
                  case 'function_handle'
                    % stores the logical operators in a cell array
                    fh_list{end+1} = obj;
                end
                query(1) = [];
            end
            
            while size(unit_status,2)>1,
                unit_status(:,2) = fh_list{1}(unit_status(:,1),unit_status(:,2));
                unit_status(:,1) = [];
                fh_list(1) = [];
            end

            units = find(unit_status);
        end

        function Session = load_ufr(Session,varargin) 
        %Session = load_ufr(Session,varargin) 
        %load Unit Firing Rate 
        %twin - double: time window for rate calculation
        %  Default: 0.05 - seconds
        %
            [newSampleRate,flength,twin] = DefaultArgs(varargin,{Session.lfpSampleRate,Session.xyzPeriods(end)-Session.xyzPeriods(1)+1,0.05});
            if ~exist([Session.spath Session.name '.ufr'],'file'),
                [Res,Clu,Map] = LoadCluRes(fullfile(Session.spath,Session.name));

                gwin = gausswin(round(twin*Session.sampleRate))/sum(gausswin(round(twin*Session.sampleRate)));
                spks = zeros(max(Res),1);
                ufr = [];
                for unit = 1:size(Map,1),
                    uRes = Res(Clu==unit);
                    uClu = Clu(Clu==unit);
                    spks(:)=0;
                    spks(uRes) = 1;
                    ufr(:,unit) =resample(conv(spks,gwin),Session.lfpSampleRate,Session.sampleRate);
                end
                
                save([Session.spath Session.name '.ufr'],'ufr','-v7.3','-mat');
                ufr = ufr(Session.syncPeriods(1):Session.syncPeriods(end),:);
            else 
                load([Session.spath Session.name '.ufr'],'-mat')
                ufr = ufr(Session.syncPeriods(1):Session.syncPeriods(end),:);
            end
            
            if newSampleRate == Session.lfpSampleRate,
                Session.ufr = ufr;
            else
                uind = round(linspace(round(Session.lfpSampleRate/newSampleRate),size(ufr,1),flength));
                Session.ufr = ufr(uind,:);
            end
        end

        function Session = load_CluRes(Session,varargin)
        %Session = load_CluRes(Session,varargin)
        %load unit timing
        %sampleRate - double: sample rate to which res is to be resampled
        %  Default: 1250 - lfpSampleRate
        %
        %units - int: the unit id's you wish to load.
        %states - string/cellArray(string): specify a state or a
        %         union/intersection of states
        %  note: only use single states for the moment!!
        %  Default: {} 
        %
        %sets:
        %    Session.res = Res;
        %    Session.clu = Clu;
        %    Session.map = Map;

            [sampleRate,units,states] = DefaultArgs(varargin,{Session.lfpSampleRate,[],{}});
            [Res Clu Map] = LoadCluRes([Session.spath Session.name]);
            Res = round(Res*sampleRate/Session.sampleRate);
            [Res ind] = SelectPeriods(Res,round([Session.syncPeriods(1),Session.syncPeriods(end)]./Session.lfpSampleRate.*sampleRate),'d',1,1);
            Clu = Clu(ind);            
            if isempty(units),
                cind = true(numel(Res),1);
            else
                cind = find(ismember(Clu,units));
            end
            Session.res = Res(cind);
            Session.clu = Clu(cind);
            Session.map = Map;
            if ~isempty(states);
                [Session.res sind] = SelectPeriods(Session.res,Session.statePeriods(states,sampleRate),'d',1,0);
                Session.clu = Session.clu(sind);            
            end
        end

        function Session = load_ripples(Session,channels,varargin)
        %Session = load_ripples(Session,channels,varargin)
        %load ripple detection file '.spw'
        %channels - int/array: channels to use to detect ripples
        %overwrite - boolean: flag to overwrite spw file
        %  Default: 0 - do not overwrite
        %thresh - int: cut off threshold of ripple power based on
        %              standard deviations from the mean
        %  Default: 3 - std
        %
        [overwrite,thresh] = DefaultArgs(varargin,{0,3});
            if ~exist([Session.spath Session.name '.spw'],'file')|overwrite,
                DetectRipples([Session.spath Session.name],channels,[],thresh);
            end
            Rips = load([Session.spath Session.name '.spw'],'file');
            [~,rpind] = SelectPeriods(Rips(:,1),[Session.syncPeriods(1),Session.syncPeriods(end)],'d',1,1);
            Rips = Rips(rpind,:);
            Session.ripples = Rips;
        end

        %% Spike features, xyz, ang, vel, acc, ufr
        function spks = spkFeatures(Session,varargin)
        %spks = spkFeatures(Session,varargin)
        %map unit timing to postion and head direction
        %
        %states   - cellarray: individual state labels
        %           e.g. states = {'head','theta'} or 'head';
        %
        %features - cellarray: individual feature labels
        %           corresponding to properties of MTASession

            [states,features] = DefaultArgs(varargin,{{'walk'},{'xyz'}});
            
            %% Load MTASession object if Session is type char
            if ~isa(Session,'MTASession'),Session = MTASession(Session,mazeName);end
           
            %% Load State specific periods
            [stsp stateLabel] = Session.statePeriods(states,Session.xyzSampleRate);

            %% Load Units and rescale sampling freq
            if isempty(Session.clu),
                Session = Session.load_CluRes(Session.xyzSampleRate);
            end
            [myRes ind] = SelectPeriods(Session.res,stsp,'d',1,1);
            myClu = Session.clu(ind);

            for i = 1:length(features),
                if ~iscell(features{i}),
                    features{i} = {features{i}};
                end

                fets.(features{i}{1})=[];
                spks.(features{i}{1})=[];

                if isprop(Session,features{i}{1}),
                    if isempty(Session.(features{i}{1})),
                        Session = Session.loadFields(features(i));
                    end
                    fets.(features{i}{1}) = Session.(features{i}{1});
                elseif ismethod(Session,features{i}{1})
                    fets.(features{i}{1}) = Session.(features{i}{1});
                end
                
                tfet = SelectPeriods(fets.(features{i}{1}),stsp,'c', 1,1);
                fets.(features{i}{1}) = reshape(tfet,[],size(fets.(features{i}{1}),2),size(fets.(features{i}{1}),3),size(fets.(features{i}{1}),4));             
            end

            for g=1:size(Session.map,1)
                myspk = myRes(myClu==g);
                for i = 1:length(features),
                    switch features{i}{1},
                      case 'ufr'
                        spks(g).(features{i}{1}) = fets.(features{i}{1})(myspk,g); 
                      otherwise
                        spks(g).(features{i}{1}) = fets.(features{i}{1})(myspk,:,:,:); 
                    end
                end
            end
            
        end

        %%---------------------------------------------------------------------------------%




        %% Model Statistics and Corrections based on Session Data--------------------------%

        function Session = updateModel(Session,varargin)
        %Session = updateModel(Session,depth)
        %update or create model, used for error correction
        %
        %  depth - int: default is 3, leave it alone
        %
            [depth] = DefaultArgs(varargin,{3});
            
            dist = Session.ang(:,:,:,3);
            dist_std = zeros(Session.Model.N,Session.Model.N,depth);
            dist_mean = zeros(Session.Model.N,Session.Model.N,depth);
            dist_error = zeros(size(Session.xyz,1),Session.Model.N,Session.Model.N,depth);
            fdist = sum(sum(dist,2),3);
            zdist = (fdist-mean(fdist(~isnan(fdist))))/std(fdist(~isnan(fdist)));
            for i = 1:Session.Model.N,
                for j = 1:Session.Model.N,
                    tdist = sq(dist(:,i,j));
                    dist_std(i,j,1)  =  std(tdist(~dist_error(:,i,j,1)&~isnan(tdist)&zdist<1));
                    dist_mean(i,j,1) = mean(tdist(~dist_error(:,i,j,1)&~isnan(tdist)&zdist<1));
                    dist_error((tdist(~isnan(tdist))>(dist_std(i,j,1)+dist_mean(i,j,1)))|(tdist(~isnan(tdist))<(-dist_std(i,j,1)+dist_mean(i,j,1))),i,j,1)=1;
                    for k = 2:depth,
                        dist_std(i,j,k)  =  std(tdist(~dist_error(:,i,j,k-1)&~isnan(tdist)&zdist<1));
                        dist_mean(i,j,k) = mean(tdist(~dist_error(:,i,j,k-1)&~isnan(tdist)&zdist<1));
                        dist_error((tdist(~isnan(tdist))>(dist_std(i,j,k)+dist_mean(i,j,k)))|(tdist(~isnan(tdist))<(-dist_std(i,j,k)+dist_mean(i,j,k))),i,j,k)=1;
                    end
                end
            end
            Session.Model.imdMean = dist_mean;
            Session.Model.imdStd = dist_std;

            % Find Index within the Session with Best Fit - Though
            % best to select it by eye
            model_index = 0;
            for i = 0:depth-1,
                model_index = find(sum(sum(dist_error(:,:,:,depth-i),2),3)==0);
                model_index = model_index(randi(length(model_index)));
                if model_index, break, end
            end    
            Session.Model.index = model_index;                    
        end


        function Session = correctRigidBody(Session,varargin)
        %Session = correctRigidBody(Session,markerSubset,depth,modelIndex,display)
        %find rigid body errors and correct them, if possible  
        %uses model frame as a basis for the geometrical
        %organization of the rigid body
        %
        %  markerSubset - cellArray: group of markers included in
        %                            the rigid body
        %                            
        %    (e.g. {'head_back','head_left','head_front','head_right','head_top'})
        %
        %  depth - int: just leave this alone, since the default works fine
        %  modelIndex - int: xyz index which contains an ideal constellation
        %                    of markers in the rigid body 
        %  display - boolean: display rb errors (only for head)
        %

            [markerSubset,depth,modelIndex,display] = DefaultArgs(varargin,{{'head_back','head_left','head_front','head_right','head_top'},3,[],0});
            if size(Session.Model.imdMean,3)~=3|Session.Model.index==0,
                Session = Session.updateModel(depth);
            end
            rb = Session.Model.rb(markerSubset);
            if ~isempty(modelIndex), Session.Model.index = modelIndex; end
            pose = sq(Session.xyz(Session.Model.index,Session.Model.gmi(markerSubset),:));
            for i = 1:size(Session.xyzPeriods,1),
                Temp = MTATrial(Session,{},[],Session.xyzPeriods(i,:));
                Temp = CorrectRigidBody(Temp,rb,pose);
                Session.xyz(Temp.xyzPeriods(1,1):Temp.xyzPeriods(1,2),:,:) = Temp.xyz;
            end
            Session.ang = Session.load_ang(1);
            if display, PlotSessionErrors(Session),end
        end

        function Session = correctPointErrors(Session,varargin)
        %Session = correctPointErrors(Session,varargin)
        %

            [markerSubset] = DefaultArgs(varargin,{{'head_back','head_left','head_front','head_right','head_top'}});
            rb = Session.Model.rb(markerSubset);
            for i = 1:size(Session.xyzPeriods,1),
                Temp = MTATrial(Session,{},[],Session.xyzPeriods(i,:));
                Temp = CorrectPointErrors(Temp,rb);
                Session.xyz(Temp.xyzPeriods(1,1):Temp.xyzPeriods(1,2),:,:) = Temp.xyz;
            end
            Session.ang = Session.load_ang(1);
        end

        function Session = addMarker(Session,name,color,sticks,xyz)
        %Session = addMarker(Session,name,color,sticks,xyz)
        %modify Model and xyz by adding an additional marker
        %
        %  name - string: marker descriptor (e.g.'bodypart_position')
        %  color - numericArray: rgb values range - [0,1] (e.g.[0.4,1,0])
        %  sticks - cellArray: information used to visualize connections/spatial
        %                      organizations of markers
        %                      {'marker_name1','marker_name2',[stick_color]}
        %                      (e.g. {'head_front','head_back',[0,0,1]})
        %
        %             marker_name1 - string: marker descriptor (e.g.'bodypart_position')
        %             marker_name2 - string: marker descriptor (e.g.'bodypart_position')
        %             stick_color - numericArray: rgb values range - [0,1] (e.g.[0.4,1,0])
        %

            Marker = MTAMarker(name,color);
            Session.Model.Markers{end+1} = Marker;
            Session.Model.N = Session.Model.N + 1;
            for i = 1:length(sticks),
                Session.Model.Connections{end+1} = MTAStick(sticks{i}{1},sticks{i}{2},sticks{i}{3});
            end
            Session.xyz = cat(2,Session.xyz,xyz);
        end

        %%---------------------------------------------------------------------------------%




        %% Place Fields -------------------------------------------------------------------%

        function Session = load_Pfs(Session,varargin)
        %Session = load_Pfs(Session,pf_search)
        %
        %loads and populates Pfs field of a Session
        %loads all saved place fields by default
        %
        %pf_search - MTAPlaceField: contains ratemap, bins and
        %                           all calculation parameters
        %
        %pf_search - cellArray: contains PlaceField states as found
        %                       in the third varargin option of the
        %                       MTAPlaceField Class
        %            e.g. {'rear',{'rear','theta'}};
        %
        %-----------------------------------------------------------
        %
        %  Example:
        %    load all placefields calculated to date
        %
        %    Session = Session.load_Pfs();
        %
        %-----------------------------------------------------------
        %
        %  load placefields with specified parameters
        %
        %    pf_search = MTAPlaceField([]);
        %    pf_search.mazeName = 'cof';
        %    pf_search.trialName = 'all';
        %    pf_search.trackingMarker = 'head_front';
        %    pf_search.stateLabel = 'head.theta';
        %    pf_search.spk_shuffle = 'n';
        %    pf_search.pos_shuffle = 0;
        %    pf_search.numBSiterations = 1;
        %    pf_search.numZslices = 1;
        %    pf_search.nbins = 50;
        %    pf_search.smooth = 0.03;
        %    
        %    Session = Session.load_Pfs(pf_search);
        %
        %-----------------------------------------------------------
        %
        %  load placefields specified by state and with default
        %  parameters 
        %
        %    Session = Session.load_pfs({'rear',{'rear','theta'}}); 
        %
        %-----------------------------------------------------------

            [Pfs_search]=DefaultArgs(varargin,{{}});
            if ischar(Pfs_search),
                for i = 1:numel(Pfs_search)                    
                    Session.Pfs{1} = MTAPlaceField(Session,[],Pfs_search);
                end
                return

            elseif iscell(Pfs_search),
                Pfs = {};
                for i = 1:numel(Pfs_search)
                    Session.Pfs{i} = MTAPlaceField(Session,[],Pfs_search{i});
                end
                return
            elseif ~isempty(Pfs_search),
                Session = Session.load_MTAObject('Pfs');
                Session.Pfs = Session.getPfs(Pfs_search);
                return
            end
        end

        function Pfs = getPfs(Session,Pfs_search)            
        %Pfs = getPfs(Session,pf_search)       
        %returns existing place fields loaded in Session
        %
        %pf_search - cellArray: contains PlaceField states as found
        %                       in the third varargin option of the
        %                       MTAPlaceField Class
        %            e.g. {'rear',{'rear','theta'}};
        %                                  
        %
        %pf_search - MTAPlaceField: contains ratemap, bins and
        %                                  all calculation parameters
        %
        %See MTASession.load_Pfs() for further help
        %
            if ischar(Pfs_search),
                for i = 1:numel(Pfs_search)                    
                    Pfs = MTAPlaceField(Session,[],Pfs_search);
                end
                return

            elseif iscell(Pfs_search),
                Pfs = {};
                for i = 1:numel(Pfs_search)                    
                    Pfs{i} = MTAPlaceField(Session,[],Pfs_search{i});
                end
                return

            elseif isa(Pfs_search,'MTAPlaceField')
                Pfs = Session.findObj('Pfs',Pfs_search);
                return
            end
        end

        %%---------------------------------------------------------------------------------%

        function Session = load_MTAObject(Session,Object_File_Tag,varargin)
            [MTAObject_search,safe_load]=DefaultArgs(varargin,{{},true});
            Session.(Object_File_Tag) = {};
            files = dir(Session.spath);
            re = ['\.' Object_File_Tag '\.'];
            objFileList = {files(~cellfun(@isempty,regexp({files.name},re))).name};
            objFileSize = {files(~cellfun(@isempty,regexp({files.name},re))).bytes};
            for i = 1:length(objFileList),
                if objFileList{i},
                    if objFileSize{i}>100000000,continue,end
                    obj = load([Session.spath objFileList{i}]);
                    type = fieldnames(obj);
                    if strcmp(obj.(type{1}).mazeName,Session.Maze.name),
                        Session.(Object_File_Tag){end+1} = obj.(type{1});
                    end
                end
            end
            if ~isempty(MTAObject_search),
                Session.(Object_File_Tag) = Session.findObj(MTAObject_search);
            end
        end

        function Objs = findObj(Session,Object_File_Tag,MTAObject_search)
            Objs = {};
            prop = properties(MTAObject_search);
            for j = 1:length(Session.(Object_File_Tag)),
                matchCnt = 0;
                numProp = length(prop);
                for g = 1:length(prop),

                    if isequal(Session.(Object_File_Tag){j}.(prop{g}),getfield(MTAObject_search,prop{g}))&~isempty(getfield(MTAObject_search,prop{g}))
                        matchCnt = matchCnt + 1;
                    elseif isempty(getfield(MTAObject_search,prop{g}))
                        numProp = numProp-1;
                    end
                end
                if matchCnt == numProp & matchCnt>0,
                    Objs{end+1} = Session.(Object_File_Tag){j};
                end
            end
            if length(Objs)==1,
                Objs = Objs{1};
            end
        end

        function trialNames = list_trialNames(Session)
            trialNames = {};
            files = dir(Session.spath);
            re = ['\.trl\.'];
            trlFileList = {files(~cellfun(@isempty,regexp({files.name},re))).name};
            for file = 1:length(trlFileList),
                points = regexp(trlFileList{file},'[.]');
                fileparts = [1 points+1; points-1 length(trlFileList{file})]';
                if size(fileparts,1)==5,
                    trialNames{end+1} = trlFileList{file}(fileparts(3,1):fileparts(3,2));
                end
            end
        end

        function Session = updateBhvSource(Session,varargin)
            [triallist] = DefaultArgs(varargin,{{Session.trialName}});
            tempSession = Session;
            for i = 1:length(triallist),
                if ~strcmp(Session.trialName,triallist{i})
                    Session = MTATrial(Session.name,{},triallist{i},[],0,Session.Maze.name);
                end
                bhvModeNames = {};
                files = dir(Session.spath);
                re = [Session.name '\.' Session.Maze.name '\.' Session.trialName '\.bhv\.'];
                bhvFileList = {files(~cellfun(@isempty,regexp({files.name},re))).name};
                bhvDnumList = {files(~cellfun(@isempty,regexp({files.name},re))).datenum};
                re = ['\.mat']; 
                bhvFileListBadInd = find(cellfun(@isempty,regexp(bhvFileList,re)));
                bhvFileList(bhvFileListBadInd) = [];
                bhvDnumList(bhvFileListBadInd) = [];
                [~,newestBhvFileInd] = max(cell2mat(bhvDnumList));
                if isempty(newestBhvFileInd),continue,end
                load([Session.spath bhvFileList{newestBhvFileInd}])
                bhvmode = Bhv.mode;
                Session.Bhv = {};
                clear('Bhv');
                Session = Session.load_Bhv(bhvmode);
                Session.save;
            end
            Session = tempSession;;
        end

        function Trial = consolidateTrials(Session,varargin)
            if ~isa(Session,'MTASession')&isa(Session,'MTATrial'),
                Session = MTASession(Session.name,{},Session.Maze.name);
            end
            [newTrialName,trialnames] = DefaultArgs(varargin,{'cnsldtd',Session.list_trialNames});
            re = 'all';
            allInd = find(~cellfun(@isempty,regexp(trialnames,re)));
            if ~isempty(allInd),
                trialnames(allInd) = [];                        
            end
            re = newTrialName;
            allInd = find(~cellfun(@isempty,regexp(trialnames,re)));
            if ~isempty(allInd),
                trialnames(allInd) = [];                        
            end
            Bhv = MTABhv([],'cnsldtd');
            newXYZPeriods = [];
            for i = 1:length(trialnames),
                Trial = MTATrial(Session,{},trialnames{i},[],0,Session.Maze.name,'minimal');
                newXYZPeriods = cat(1,newXYZPeriods,Trial.xyzPeriods);
                if i==1,
                    Bhv.States = Trial.Bhv.States;
                    for j = 1:length(Bhv.States),
                        Bhv.States{j}.state = Bhv.States{j}.state+Trial.xyzPeriods(1);
                    end
                else
                    for j = 1:length(Bhv.States),
                        Bhv.States{j}.state = cat(1,Bhv.States{j}.state,Trial.Bhv.getState(Bhv.States{j}.label).state+Trial.xyzPeriods(1));
                        if i==length(trialnames),
                            Bhv.States{j}.state = sort(Bhv.States{j}.state)-min(newXYZPeriods(:));
                        end
                    end
                end                                
            end
            newXYZPeriods = sort(newXYZPeriods);
            Trial = MTATrial(Session,{},newTrialName,newXYZPeriods,1,Session.Maze.name,'minimal');            
            Trial.Bhv = Bhv;
            Bhv.save(Trial,1);
            Trial.save
        end
        
        function Session = filter(Session,varargin)
        %Session = filter(Session,field_name,kernel)       
        %filters a field with specified kernel
        %
        %  field_name - string/cellArray(string): string of the property to be filtered
        %
        %  kernel - numericArray: the weighted kernal used in the convolution
        %
        %  example:
        %    
        %    Session = Session.filter('xyz',gausswin(9)./sum(gausswin(9))
        %
            [field_name,kernel] = DefaultArgs(varargin,{'xyz',gausswin(9)./sum(gausswin(9))});
            padding_length = length(kernel);
            fFieldData = zeros(size(Session.(field_name)));
            tFieldData = fFieldData;
            tFieldData = cat(1,tFieldData,tFieldData(1:2*padding_length,:,:,:,:));

            tFieldData(1:padding_length,:,:,:,:) = flipdim(Session.(field_name)(1:padding_length,:,:,:,:),1);
            tFieldData(padding_length+1:size(fFieldData,1)+padding_length,:,:,:,:) = Session.(field_name);
            
            tFieldData(end-padding_length:end,:,:,:,:) = flipdim(Session.(field_name)(end-padding_length:end,:,:,:,:),1);
            
            tFieldData = reshape(Filter0(kernel,tFieldData),size(tFieldData));

            Session.(field_name) = tFieldData(padding_length+1:size(fFieldData,1)+padding_length,:,:,:,:);

        end

        function Session = resample(Session,field,prevSampleRate,newSampleRate)            
        end


        function printFig(Session,varargin)
            [handle,imFileType,id,name,path] = DefaultArgs(varargin,{gcf,'png',[],num2str(randi(100000,1)),['~/figures/f' datestr(now,29)]});
            if ~exist(path,'dir'),
                mkdir(path),
            end
            if ~isempty(id), id = [ '.' num2str(id)];,end
            switch imFileType
              case 'eps'
                print(handle,'-dpsc2',[path '/' Session.filebase '.' name id '.' imFileType]);
              case 'png'
                print(handle,'-dpng',[path '/' Session.filebase '.' name id '.' imFileType]);
            end
        end

    end %methods

end %MTASession

