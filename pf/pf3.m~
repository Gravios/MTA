function pfs = pf3(Session,varargin)
% function pfs = pf3(Session,varargin)
% [states,mode,units,numBSiterations,numZslices,display,nbins,mazeName,trialName,constrained_to_maze,recalculate]=DefaultArgs(varargin,{'rear','calculate',0,100000,0,0,100,'cof','',1,0});

[states,mode,units,spk_shuffle_function,shift_position,numBSiterations,numZslices,smooth,nbins,mazeName,trialName,constrained_to_maze,recalculate]=DefaultArgs(varargin,{'rear','compute',0,'normal',0,100000,0,0.02,100,'cof','',1,1});

%% Load MTASession object if Session is type char
if ~isa(Session,'MTASession'),Session = MTASession(Session,mazeName);end

%% Load State specific periods
[stsp stateLabel] = Session.statePeriods(states);
pf3_filename = [Session.spath.analysis Session.filebase '.pf3.' Session.trackingMarker '.' stateLabel '.' num2str(numZslices) '.mat'];
switch mode
  case 'load'
    %% filename for pf3 calculations
    pfs = load(pf3_filename);
  case 'compute'
    %% Load Units and rescale sampling freq
    Par = LoadPar([Session.spath.nlx Session.name '.xml']);
    [Res Clu Map] = LoadCluRes([Session.spath.nlx Session.name]);
    Res = round(Res*Par.lfpSampleRate/Par.SampleRate);

    %% Constrain the computational volume
    if ~constrained_to_maze,
        maxz = max(sq(Session.xyz(:,Session.Model.gmi(Session.trackingMarker),3)));
        minz = min(sq(Session.xyz(:,Session.Model.gmi(Session.trackingMarker),3)));
    else
        minz = Session.Maze.boundaries(3,1);
        maxz = Session.Maze.boundaries(3,2);
    end

    %% Calculate Slice Intervals
    if ~numZslices,
        numZslices = 1;
    elseif length(numZslices)>1
        sliceIntervals=numZslices;
        numZslices = length(numZslices)-1;
    else
        sliceIntervals = minz+((maxz-minz)/numZslices).*[0:numZslices];
    end


    %% Create dummy pf3 file for instances where a particular state(s) was never occupied
    if isempty(stsp),
        calculation_completion_map = ones(max(Clu),1);
        maxRate    = cell(max(Clu),numZslices);
        maxRateMax = cell(max(Clu),numZslices);
        maxRateInd = cell(max(Clu),numZslices);
        maxRatePos = cell(max(Clu),numZslices);
        rateMap    = cell(max(Clu),numZslices);
        meanMap    = cell(max(Clu),numZslices);
        stdMap     = cell(max(Clu),numZslices);
        bin1       = cell(max(Clu),numZslices);
        bin2       = cell(max(Clu),numZslices);
        save([ Session.spath.analysis Session.filebase '.pf3.' Session.trackingMarker '.' stateLabel '.' num2str(numZslices) '.mat'], ...
             'rateMap','bin1','bin2','Map','numZslices', ...
             'maxRate','maxRateMax','maxRateInd','maxRatePos','-v7.3');        
        return
    end


    pos = sq(Session.xyz(:,Session.Model.gmi(Session.trackingMarker),[1 2]));


    %% Select Segments Constrained to State and/or Height
    for slice=1:numZslices,
        if numZslices>1
            posSlice=Session.xyz(:,Session.Model.gmi(Session.trackingMarker),3);
            posSlice(Session.xyz(:,Session.Model.gmi(Session.trackingMarker),3)>sliceIntervals(slice)&Session.xyz(:,Session.Model.gmi(Session.trackingMarker),3)<sliceIntervals(slice+1))=1;
            posSlice(posSlice~=1)=0;
            slicePosPeriods = [];
            slicePosPeriods = ThreshCross(posSlice,0.5,1);
            slicePosPeriods = round(slicePosPeriods*Session.lfpSampleRate/Session.xyzSampleRate+Session.syncPeriods(1,1));
            stspz = IntersectRanges(stsp,slicePosPeriods);
        else
            stspz = stsp;
        end
        [myRes{slice} ind{slice}] = SelectPeriods(Res,stspz,'d',1,1);
        myClu{slice} = Clu(ind{slice});

        stspos{slice} = SelectPeriods(pos,round((stspz-Session.syncPeriods(1,1))/Session.lfpSampleRate*Session.xyzSampleRate)+1, 'c', 1);
    end

    %% Instantiate pf3 variables
    calculation_completion_map = zeros(max(Clu),1);
    rateMap    = cell(max(Clu),numZslices);
    meanMap    = cell(max(Clu),numZslices);
    stdMap     = cell(max(Clu),numZslices);
    bsMap      = zeros(numBSiterations,nbins,nbins);
    bin1       = cell(max(Clu),numZslices);
    bin2       = cell(max(Clu),numZslices);
    maxRate    = cell(max(Clu),numZslices);
    maxRateMax = cell(max(Clu),numZslices);
    maxRateInd = cell(max(Clu),numZslices);
    maxRatePos = cell(max(Clu),numZslices);



    %% If terminal error occurred during a previous run
    %% pick up from the last unit.
    %%pf3_filename = [Session.spath.analysis Session.filebase '.pf3.' Session.trackingMarker '.' stateLabel '.' num2str(numZslices) '.mat'];

    if exist(pf3_filename,'file'),
        load(pf3_filename);
    end

    startAtUnit = 1;
    if recalculate&~units,
        calculation_completion_map = zeros(size(calculation_completion_map));
    else
        calculation_completion_map(units) = 0;
        for i = 1:max(Clu),
            if ~calculation_completion_map(i), startAtUnit = i;end
        end
    end
    %% If no specific unit(s), calculate all pfs
    if ~units,
        units = startAtUnit:max(Clu);
    end

    %% Calculate place fields for specified units
    for unit= units,

        if calculation_completion_map(unit),continue,end  %% Skip unit if already calculated

        fprintf('unit: %d',unit)
        for slice = 1:numZslices,
            rateMap{unit,slice} = zeros(nbins,nbins);
            meanMap{unit,slice} = zeros(nbins,nbins);
            stdMap{unit,slice} = zeros(nbins,nbins);
            mySpk = myRes{slice}(myClu{slice}==unit);
            nSpk = length(mySpk);
            if nSpk>3,                                    %% Skip unit if too few spikes
                
                %% CircShift position data
                if shift_position,
                    stspos{slice} = circshift(stspos{slice},shift_position);
                end
                
                switch spk_shuffle_function
                  case 'normal'
                    shuffled_SpkInd = repmat(1:nSpk,numBSiterations,1);
                  case 'random'
                    shuffled_SpkInd = randi(nSpk,numBSiterations,nSpk);
                end
                    
                [bsMap(1,:,:) bin1{unit,slice} bin2{unit,slice}] =  PlotPF(Session,mySpk(shuffled_SpkInd(1,:)),stspos{slice}(:,1),stspos{slice}(:,2),nbins,smooth,constrained_to_maze);
                                    
                if isempty(numBSiterations),
                    %% BootStrap Iterations
                    for bsi = 2:numBSiterations,
                        bsMap(bsi,:,:) =  PlotPF(Session,mySpk(shuffled_SpkInd(bsi,:)),stspos{slice}(:,1),stspos{slice}(:,2),nbins,smooth,constrained_to_maze);
                    end

                    rateMap{unit,slice} = PlotPF(Session,mySpk,stspos{slice}(:,1),stspos{slice}(:,2),nbins,smooth,constrained_to_maze);
                    meanMap{unit,slice} = sq(mean(bsMap,1));
                    stdMap{unit,slice} = sq(std(bsMap,0,1));
                else
                    rateMap{unit,slice} = sq(bsMap(1,:,:));
                    meanMap{unit,slice} = zeros(nbins,nbins);
                    stdMap{unit,slice} = zeros(nbins,nbins);
                end

                rateMap{unit,slice}(isnan(rateMap{unit,slice})) = 0;

                %tempMap = permute(reshape(repmat(rateMap{unit,slice},numBSiterations,1),nbins,numBSiterations,nbins),[2,1,3]);
                %pvalMap = sq(sum(bsMap>tempMap)./numBSiterations);

                if isempty(rateMap{unit,slice}), continue, end,
                maxRateInd{unit,slice} = LocalMinima2(-rateMap{unit,slice},-0.2,12);
                if isempty(maxRateInd{unit,slice}), continue, end,
                maxRatePos{unit,slice} = [bin2{unit,slice}(maxRateInd{unit,slice}(:,2));bin1{unit,slice}(maxRateInd{unit,slice}(:,1))]'*[0 1; 1 0];
                maxRate{unit,slice} = rateMap{unit,slice}(round(size(rateMap{unit,slice},1)*[maxRateInd{unit,slice}(:,2)-1]+maxRateInd{unit,slice}(:,1)));
                [~,maxRateMax{unit,slice}] = max(maxRate{unit,slice});
            end
        end
        save(pf3_filename,'rateMap','meanMap','stdMap','bin1','bin2','Map', ...
             'numZslices','maxRate','maxRateMax','maxRateInd','maxRatePos','-v7.3');
        calculation_completion_map(unit) = 1;
    end
end


% $$$ figure,imagesc(1:nbins,1:nbins,rateMap)
% $$$ figure,imagesc(1:nbins,1:nbins,meanMap{unit,slice}),colorbar
% $$$ figure,imagesc(1:nbins,1:nbins,stdMap{unit,slice}),colorbar
% $$$ figure,imagesc(1:nbins,1:nbins,meanMap{unit,slice}./stdMap{unit,slice}),colorbar
% $$$ figure,imagesc(1:nbins,1:nbins,rateMap.*(ones(nbins,nbins)*3<(meanMap{unit,slice}./stdMap{unit,slice}))),colorbar
