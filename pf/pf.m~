classdef pf

    properties (SetAccess = public)

        %mazeName - string: 3-4 letter name of the 
        %  testing arena (e.g. 'rof' := rectangular open-field)
        mazeName

        %trialName - string: designation of trial, 
        %  the full Session has the default name 'all'
        trialName

        %trackingMarker - string: Marker name used for 
        %  place field calculations
        trackingMarker

        %stateLabel - string: state(s) used to define periods 
        %  used to calculate place fields
        stateLabel

        %rateMap - cellArray -> numericArray: {clu}(bin1,bin2) 
        %  unit firing rate map
        rateMap

        %stdMap -  cellArray -> numericArray: {clu}(bin1,bin2) 
        %  standard deviation of unit firing rate map
        stdMap

        %bin1 - cellArray -> numericArray: {clu}(x-position) 
        %  spatial bins associated with rateMap and stdMap
        bin1

        %bin2 - cellArray -> numericArray: {clu}(y-position) 
        %  spatial bins associated with rateMap and stdMap
        bin2

        %nbins - int: number of bins with which to calculate 
        %  the place field (i.e. the place field resolution)
        nbins

        %cluMap - numericArray: (clu,electrode_clu,eletrode) mapping of unit clusters 
        %  to electrode cluster and electrode
        cluMap

        %smooth - double: smoothing factor for gaussian 
        %  smoothing of occupancy and rate maps
        smooth

        %maxRate - cellArray -> numericArray: {clu}(peak_rates_of_placefield)
        maxRate

        %maxRateMax -cellArray -> int: {clu}(index_maxRate) index of maxRate
        %  corresponding to the overall maximum rate of the place field
        maxRateMax

        %rateMap - cellArray -> numericArray: {clu}(maxRate,[bin1,bin2]) 
        maxRateInd

        %rateMap - cellArray -> numericArray: {clu}(maxRate,[x-position,y-position]) 
        maxRatePos

        %numZslices - int: number of planes to split place fields
        numZslices

        %numBSiterations - int: number of random interations
        numBSiterations

        %calculation_completion_map - booleanArray: indicates if
        %  place field for a unit has been calculated
        calculation_completion_map    

        %spk_shuffle - string: shuffling method
        %                      'n': normal indexing
        %                      'r': randomly shuffled spike time index
        spk_shuffle

        %pos_shuffle - int: range of random position shuffle 
        %  (e.g. pos_shuffle = 40000 -> [-40000,40000]
        pos_shuffle
    end

    methods
        function PlaceField = pf(Session,varargin)
            [units,states,overwrite,spk_shuffle,pos_shuffle,numBSiterations,numZslices,smooth,nbins,mazeName,trialName,constrained_to_maze]=DefaultArgs(varargin,{0,'walk',0,'n',0,1,0,0.03,50,'cof','',1});

            PlaceField.mazeName = Session.Maze.name;
            PlaceField.trialName = Session.trialName;
            %% Load MTASession object if Session is type char
            if ~isa(Session,'MTASession'),Session = MTASession(Session,mazeName);end

            %% Constrain the computational volume
            if ~constrained_to_maze,
                maxz = max(sq(Session.xyz(:,Session.Model.gmi(Session.trackingMarker),3)));
                minz = min(sq(Session.xyz(:,Session.Model.gmi(Session.trackingMarker),3)));
            else
                minz = Session.Maze.boundaries(3,1);
                maxz = Session.Maze.boundaries(3,2);
            end

            %% Calculate Slice Intervals
            if ~numZslices,
                numZslices = 1;
            elseif length(numZslices)>1,
                sliceIntervals=numZslices;
                numZslices = length(numZslices)-1;
            else
                sliceIntervals = minz+((maxz-minz)/numZslices).*[0:numZslices];
            end

            %% Load Units and rescale sampling freq
            [Res Clu cluMap] = LoadCluRes([Session.spath.nlx Session.name]);
            Res = round(Res*Session.lfpSampleRate/Session.sampleRate);
            [Res ind] = SelectPeriods(Res,[Session.syncPeriods(1),Session.syncPeriods(end)],'d',1,1);
            Clu = Clu(ind);


            %% Load State specific periods
            [stsp stateLabel] = Session.statePeriods(states);

            %% Instantiate pf3 variables

            PlaceField.trackingMarker = Session.trackingMarker;
            PlaceField.stateLabel = stateLabel;


            PlaceField.calculation_completion_map = zeros(max(Clu),1);
            PlaceField.maxRate    = cell(max(Clu),numZslices);
            PlaceField.maxRateMax = cell(max(Clu),numZslices);
            PlaceField.maxRateInd = cell(max(Clu),numZslices);
            PlaceField.maxRatePos = cell(max(Clu),numZslices);
            PlaceField.rateMap    = cell(max(Clu),numZslices);
            PlaceField.stdMap     = cell(max(Clu),numZslices);
            PlaceField.bin1       = cell(max(Clu),numZslices);
            PlaceField.bin2       = cell(max(Clu),numZslices);

            PlaceField.nbins = nbins;
            PlaceField.smooth = smooth;
            PlaceField.numBSiterations = numBSiterations;
            PlaceField.spk_shuffle = spk_shuffle;
            PlaceField.pos_shuffle = pos_shuffle;

            PlaceField.cluMap = cluMap;
            PlaceField.numZslices = numZslices;

            %% Return dummy PlaceField for instances where a particular state(s) was never occupied
            if isempty(stsp),
                PlaceField.calculation_completion_map = ones(max(Clu),1);
                return
            end


            %% Check if Session already contains pf with given parameters


            %% If terminal error occurred during a previous run pick up from the last unit.    
            pf_tmpfile = [Session.spath.analysis Session.filebase '.pf.' Session.trackingMarker '.' stateLabel '.' num2str(numZslices) spk_shuffle num2str(pos_shuffle) 'bs' num2str(numBSiterations) 'sm' num2str(smooth*100) 'bn' num2str(nbins) '.mat'];
            if exist(pf_tmpfile,'file'),
                load(pf_tmpfile);
            else
                PlaceField.calculation_completion_map = zeros(max(Clu),1);
            end

            startAtUnit = 1;
            if overwrite&~units,
                PlaceField.calculation_completion_map = zeros(size(PlaceField.calculation_completion_map));
            elseif units,
                PlaceField.calculation_completion_map(units) = 0;
            else
                startAtUnit = find(PlaceField.calculation_completion_map==1,1);
                if isempty(startAtUnit),startAtUnit=1;,end
            end

            %% If no specific unit(s), calculate all pfs
            if ~units,
                units = startAtUnit:max(Clu);
            end


            pos = sq(Session.xyz(:,Session.Model.gmi(Session.trackingMarker),[1 2]));
            myRes = {};
            ind = {};
            myClu = {};
            %% Select Segments Constrained to State and/or Height
            for slice=1:numZslices,
                if numZslices>1
                    posSlice=Session.xyz(:,Session.Model.gmi(Session.trackingMarker),3);
                    posSlice(Session.xyz(:,Session.Model.gmi(Session.trackingMarker),3)>sliceIntervals(slice)&Session.xyz(:,Session.Model.gmi(Session.trackingMarker),3)<sliceIntervals(slice+1))=1;
                    posSlice(posSlice~=1)=0;
                    slicePosPeriods = [];
                    slicePosPeriods = ThreshCross(posSlice,0.5,1);
                    slicePosPeriods = round(slicePosPeriods*Session.lfpSampleRate/Session.xyzSampleRate);
                    stspz = IntersectRanges(stsp,slicePosPeriods);
                else
                    stspz = stsp;
                end

                [myRes{slice},ind{slice}] = SelectPeriods(Res,stspz,'d',1,1);
                myClu{slice} = Clu(ind{slice});
                stspos{slice} = SelectPeriods(pos,round(stspz/Session.lfpSampleRate*Session.xyzSampleRate)+1, 'c', 1);
            end



            bsMap = zeros(PlaceField.numBSiterations,PlaceField.nbins,PlaceField.nbins);
            %% Calculate place fields for specified units
            for unit=units,

                %% Skip unit if already calculated
                if PlaceField.calculation_completion_map(unit),continue,end

                fprintf('unit: %d\n',unit)
                for slice = 1:numZslices,
                    PlaceField.rateMap{unit,slice} = zeros(PlaceField.nbins,PlaceField.nbins);
                    PlaceField.stdMap{unit,slice} = zeros(PlaceField.nbins,PlaceField.nbins);
                    mySpk = myRes{slice}(myClu{slice}==unit);
                    nSpk = length(mySpk);

                    %% Skip unit if too few spikes
                    if nSpk>3,
                        %% CircShift position data                        
                        shuffled_Pos = @(pos_shuffle,stspos,slice) circshift(stspos{slice},randi([-pos_shuffle,pos_shuffle]));
                        
                        switch spk_shuffle
                          case 'n'
                            shuffled_Spk = @(nSpk) mySpk(1:nSpk);
                          case 'r'
                            shuffled_Spk = @(nSpk) mySpk(randi(nSpk,1,nSpk));
                        end
                        
                        [bsMap(1,:,:) PlaceField.bin1{unit,slice} PlaceField.bin2{unit,slice}] =  PlotPF(Session,shuffled_Spk(nSpk),shuffled_Pos(pos_shuffle,stspos,slice),nbins,smooth,constrained_to_maze);
                        if numBSiterations>1,
                            for bsi = 2:numBSiterations,
                                bsMap(bsi,:,:) = PlotPF(Session,shuffled_Spk(nSpk),shuffled_Pos(pos_shuffle,stspos,slice),nbins,smooth,constrained_to_maze);

                            end
                            PlaceField.rateMap{unit,slice} = sq(mean(bsMap,1));
                            PlaceField.stdMap{unit,slice} = sq(std(bsMap,0,1));

                        else
                            PlaceField.rateMap{unit,slice} = sq(bsMap);
                            PlaceField.stdMap{unit,slice} = zeros(size(sq(bsMap)));
                        end

                        PlaceField.rateMap{unit,slice}(isnan(PlaceField.rateMap{unit,slice})) = 0;
                        try
                            if isempty(PlaceField.rateMap{unit,slice}), continue, end,
                            PlaceField.maxRateInd{unit,slice} = LocalMinima2(-PlaceField.rateMap{unit,slice},-0.2,12);
                            if isempty(PlaceField.maxRateInd{unit,slice}), continue, end,
                            PlaceField.maxRatePos{unit,slice} = [PlaceField.bin2{unit,slice}(PlaceField.maxRateInd{unit,slice}(:,2));PlaceField.bin1{unit,slice}(PlaceField.maxRateInd{unit,slice}(:,1))]'*[0 1; 1 0];
                            PlaceField.maxRate{unit,slice} = PlaceField.rateMap{unit,slice}(round(size(PlaceField.rateMap{unit,slice},1)*[PlaceField.maxRateInd{unit,slice}(:,2)-1]+PlaceField.maxRateInd{unit,slice}(:,1)));
                            [~,PlaceField.maxRateMax{unit,slice}] = max(PlaceField.maxRate{unit,slice});
                        end
                    end
                end

                PlaceField.calculation_completion_map(unit) = 1;
                save(pf_tmpfile,'PlaceField','-v7.3')

            end
        % $$$ figure,imagesc(1:nbins,1:nbins,rateMap)
        % $$$ figure,imagesc(1:nbins,1:nbins,meanMap{unit,slice}),colorbar
        % $$$ figure,imagesc(1:nbins,1:nbins,stdMap{unit,slice}),colorbar
        % $$$ figure,imagesc(1:nbins,1:nbins,meanMap{unit,slice}./stdMap{unit,slice}),colorbar
        % $$$ figure,imagesc(1:nbins,1:nbins,rateMap.*(ones(nbins,nbins)*3<(meanMap{unit,slice}./stdMap{unit,slice}))),colorbar
        end 
    end



end
