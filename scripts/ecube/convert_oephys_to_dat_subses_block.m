function convert_oephys_to_dat_subses_block(FileList, FileOut, AcqSystem, varargin)
%oephys2dat_subses_blocks is a modification of oephys2dat_subses.m, which
%converts .continuous files from "FileList" with wideband signal
%recorded with an open ephys acquisition system to .dat data format, but
%does it in small blocks. It allows to deal with large sessions.
%This function is a supplementary function for oephys2dat and used to convert files within 
%individual subsessions (sleep_box, maze, arena and so on) of the experiment.
%Use oephys2dat.m to convert the whole experiment session.
%
%NOTE: although CH, ADC and AUX channels have different header.bitVols values, for simplicity only the CH-value (0.195) is applied to all
%      channels to convert to microvolts.Take it into account if you need real amplitudes on ADC/AUX channels.
%
%USAGE: oephys2dat_subses_blocks(FileList, FileOut, <ChanMapping>, <MaxDatFileSize_Gb>)
%
%INPUT:
% FileList       is a cell vector with a list of .continuous files to be converted.
%                Files must be generated by the same open ephys processor and belong to the same subsession. 
% FileOut        is a name of the output .dat file the converted data will be saved in.
%                Conventional naming scheme: FileBase-SubSesID-SubSesDescription.dat 
% AcqSystem      is a name of the aqcuisition system ('oephys' - open ephys; 'ecube' - eCube; 'nlx' - Neuralynx).
% <ChanMapping>  is a vector with indices of open ephys channels how they must be ordered in a .dat file. Default=[].
% <MaxDatFileSize_Gb>  is the maximum size of simultaneously loaded to RAM data. Default = 40 (empirically tested on the labs erver).
%
%OUTPUT:
% FileOut.dat      is a binary .dat file with the wideband signals (mkV).
% FileOut.dat.info is an ASCII file with info about FileOut.dat [nChannels nSamples SamplingRate_Hz].
% FileOut.dat.sts  is an ASCII file with original timestamps for samples in FileOut.dat (.dat samples)
%
%EXAMPLE: oephys2dat_subses_blocks(FileList, 'ER50-20170101-01-hc.dat', 'oephys')
%
%DEPENDENCIES:
% labbox: DefaultArgs, memorylinux, start_parallel
% oephys: load_open_ephys_header
% FMAToolbox: SaveBinary_FMAToolbox
%
% Evgeny Resnik
% version 12.04.2016
% version 07.06.2018: can deal with eCube data files
% version 18.02.2019 by Gerrit: some changes to deal without data loss with recording
% gaps and channel groups of different start/stop times, also shortened
% code

% Parse input parameters
[ChanMapping, MaxDatFileSize_Gb] = DefaultArgs(varargin,{ [], 40 });


%Setting up parallel processing (for parfor)
myPool = start_parallel;

%--------------------------------------------------------------------------------------%
%Number of files to process
nFiles = length(FileList);

%% Parse file names to extract information about the files
clear SubSesID SubSesDescription ProcessorID ChanType Chan
for k=1:nFiles
    out = regexp(FileList{k}, '-', 'split');
    SubSesID(k)          = str2num(out{3});
    SubSesDescription{k} = out{4};
    ProcessorID(k)       = str2num(out{6});
    ChanType{k}          = out{7};
    out2 = regexp(out{8}, '[.]', 'split');
    Chan(k) = str2num(out2{1});
end
clear out out2 k

%Lists of unique values
clear List_SubSesID List_ProcessorID List_ChanType List_SubSesDescription
List_SubSesID    = unique(SubSesID);
nSubSes          = length(List_SubSesID);
List_ProcessorID = unique(ProcessorID);
List_ChanType    = unique(ChanType);
for k=1:nSubSes
   ind = find(SubSesID == List_SubSesID(k), 1);
   List_SubSesDescription{k} = SubSesDescription{ind}; 
   clear ind
end

%Do few checks
if length(List_SubSesID)>1 | length(List_SubSesDescription)>1;
    error('Provided list contains files from different subsessions!')
end


%Modification from 07.06.2018 by Evgeny Resnik:
%Do not check for procesor ID because eCube system by default produce data files recorded 
% by different processors,  which still must be merged together.
% if length(List_ProcessorID)>1
%     error('Provided list contains files from different open ephys processors!')
% end

%% Modification from 07.06.2018 by Evgeny Resnik: to deal with eCube
if strcmp(AcqSystem, 'oephys')
    
    BadChanTypes = find( ~ismember(List_ChanType, {'ADC','AUX','CH'}) );
    if ~isempty(BadChanTypes)
        error('Unknown channel type(s) found! Must be "CH", "AUX" or "ADC"')
    end
    
elseif strcmp(AcqSystem, 'ecube')
    
    BadChanTypes = find( ~ismember(List_ChanType, {'PAI','PDI','CH'}) );
    if ~isempty(BadChanTypes)
        error('Unknown channel type(s) found! Must be "CH", "PAI" or "PDI"')
    end
    
end %if strcmp(AcqSystem, 'oephys')
clear BadChanTypes


%% Check that all the files exist and that file names and internal header info match
for k=1:nFiles
    
    if ~exist(FileList{k}, 'file')
        error(sprintf('File %s not found!', FileList{k}))
    end
    
    header = load_open_ephys_header(FileList{k});    
    
    %Deal with a files from eCube with additional suffixes "HS_" in file name, get rid of it first
    if length(header.channel)>5 && strcmp(header.channel(1:5),'HS_CH')
        header.channel(1:3) = [];
    end 
        
    if ismember(header.channel(1:3), {'ADC', 'AUX', 'PDI', 'PAI'})         
        Header_ChanType = header.channel(1:3);
        Header_Chan     = str2num(header.channel(4:end));
    elseif strcmp(header.channel(1:2),'CH')
        Header_ChanType = header.channel(1:2);
        Header_Chan     = str2num(header.channel(3:end));
        %Keep few parameters from an abitrary CH channel for future processing
        %(AUX/ADC channels have different bitVolts factor)
        SamplingRate = header.sampleRate;
        bitVolts     = header.bitVolts;
    end
    if Chan(k)~=Header_Chan || ~strcmp(ChanType{k}, Header_ChanType)
        error(sprintf('Channel index/type in header does not match the file name: %s  ', FileList{k}))
    end
    clear header     
    
end %loop across files


%% ---------------- Calculate parameters of a loop across data chunks -----------------------------%

%Compute size of files in the list (bytes)
for k=1:length(FileList);
fid = fopen(FileList{k});
fseek(fid,0,'eof');
FileSize_bytes_each(k) = ftell(fid);
fclose(fid);
end

figure;plot(FileSize_bytes_each)
xlabel('files')
ylabel('File Size bytes')

title([cdir ' - FileSize_bytes for each file - '])

%% set up loading parameters

%Structure of a block of .continuous data (taken from load_open_ephys_blocks.m)
blockBytes =  [8 2 2 2048 10]; 

%Compute size of a data block (bytes)
BlockSize_bytes =  sum(blockBytes);
BlockSize_samples = 1024;

%Pre-defined size of a .continuous file header (bytes)
NUM_HEADER_BYTES = 1024;

%The total number of blocks in the file
nBlocks = floor((FileSize_bytes_each - NUM_HEADER_BYTES)/BlockSize_bytes);

%Length of a data chunk (in blocks) that can be loaded simulateously across channels
% Suggested empirically.
% ChunkLength_blocks = round( (MaxDatFileSize_Gb*1e9) / (nFiles*BlockSize_bytes) );
ChunkLength_blocks = 2500;
ChunkLength_samples = ChunkLength_blocks*BlockSize_samples;

%alternative function structure:
% a) find out full session duration: get first and last absolute timepoints present in data across all files
% b) make matrix of zeros spaninng first and last absolute timepoint across all channels
% c) go through this matrix in chunks and fill all recorded data into its respective time slot

%%
%Compute number of full chunks in the file
nChunks = ceil(max(nBlocks/ChunkLength_blocks));


%establish file_end_t for all files
for k=1:nFiles
    nLastBlockEach(k)=((FileSize_bytes_each(k)-NUM_HEADER_BYTES)/BlockSize_bytes);
    if floor(nLastBlockEach(k))~=nLastBlockEach(k);
        error('Filesize not multiple of Blocksize')
    end
    [~, t, ~] = load_open_ephys_data_blocks(FileList{k}, 'unscaledInt16', [nLastBlockEach(k)-1 nLastBlockEach(k)]);
    file_end_t(k)=max(t);
end



%------------------------------------------------------------------------------------------------------------%
%%                Load from all channels and save to a .dat file:                            %
%------------------------------------------------------------------------------------------------------------%


%% load/check/correct/save all chunks
    
    %set startblock
    BlockRange2Load = repmat([1   ChunkLength_blocks],352,1)';    

    finished=0;
    n=0;
    
while finished~=1;
    
    n=n+1;
    
% %    n=1:nChunks

% %     %Block range for the given chunk
% %     BlockRange2Load = [ (n-1)*ChunkLength_blocks+1   n*ChunkLength_blocks ];    
% %          
    %% -----------  Loading section: exactly as in oephys2dat_subses.m, but for a chunk  ---------------------%
    %Initialize the variable for accumulating the data
    %Note: a cell array is used here to be able to run parfor and to accomodate cases when channels have different length
    raw   = cell(1,nFiles);
    raw_t = cell(1,nFiles); 
    
    if n~=1;
    BlockRange2Load= [nextchunk_startblock; nextchunk_endblock];
    end
    
    %Loop across files
    %Note: because PARFOR does not preserve the order of a loop iterations, channels are first
    %loaded in a random order, then sorted based on their type and index.
%     fprintf('Loading data chunk-%d of %d (1024-samples blocks %d-%d) from %d .continuous files ...', n, nChunks+1, BlockRange2Load, nFiles)
    clear Header_ChanType Header_Chan LoadedFile
    parfor k=1:nFiles
        %Load chunk across files
        [data, t, BlockInfo] = load_open_ephys_data_blocks(FileList{k}, 'unscaledInt16',BlockRange2Load(:,k));    
          
        %Store the loaded data (unscaled int16) and timestamps (samples)
        if diff(BlockRange2Load(:,k))<=1;
            data=0;
            t=0;
        end
        
        raw{k} = data;
        raw_t{k} = t;
        
        %OPTION-1: keep header information to re-order the channel later
        %another way could be to reorder channels using info from file names
        out = BlockInfo.header.channel;
        
        %Deal with a files from eCube with additional suffixes "HS_" in file name, get rid of it first
        if length(out)>5 && strcmp(out(1:5),'HS_CH')
            out(1:3) = [];
        end
        
        if ismember(out(1:3), {'ADC', 'AUX', 'PDI', 'PAI'})
            Header_ChanType{k} = out(1:3);
            Header_Chan(k)     = str2num(out(4:end));
        elseif strcmp(out(1:2),'CH')
            Header_ChanType{k} = out(1:2);
            Header_Chan(k)     = str2num(out(3:end));
        end
               
        %OPTION-2: use file names to re-order (for debugging data sets with mismatched between names and headers)
        %     Header_ChanType{k} = ChanType{k};
        %     Header_Chan(k) = Chan(k);
        
        %Keep names of actually loaded files for debugging purposes
        LoadedFile{k} = FileList{k};
        
    end  %loop across channel files
    clear data t BlockInfo out
    fprintf('DONE\n')
       
    
    %% ----------------------------- Fill data into the right timeslots ----------------------------------%
    
    fprintf('Checking data on consistency and mapping ...')    
    
    %Check whether a timestamp vector on any channel has gaps (time increment is more than one sample)
    %If it does..
    % ...fill gaps in timestamps with timestamps and corresponding data with zeros
    % Here i assume that these gaps are due to restarts of recording (while keeping acquisition running)
    % and not due to lost not-saved data.
    % well cause might not matter for dealing with it here...
            
% %     %Flag showing whether gap correction on the time vector has been done
% %     IfGapCorrected = 0;
    
     if n==1;
    %   find smallest chunk_end_t
        %Extract the very first and last timestamps across all the channels
        FirstTimestamps = cellfun(@(x) x(1), raw_t);
        FirstTimestamps = FirstTimestamps(FirstTimestamps~=0);
        
        LastTimestamps  = cellfun(@(x) x(end), raw_t);
        LastTimestamps = LastTimestamps(LastTimestamps~=0);
    
        %find first start-timestamps and first end-timestamps across files
        smallest_last_t = min(LastTimestamps);
        smallest_first_t = min(FirstTimestamps);
        %define new t for chunk between smallest_first_t and smallest_last_t
        raw_t_new=smallest_first_t:smallest_last_t;
        nextchunk_start_t=smallest_last_t+1;
     else
         raw_t_new=nextchunk_start_t : nextchunk_start_t + ChunkLength_samples;
         nextchunk_start_t = raw_t_new(end) + 1;
     end  
    % across channels: n==1 keep all data falling between smallest_first_t and smallest_last_t
    %                  n>1  keep all data falling within largest 
        % empty data points filled with zeros
        for k=1:nFiles
            [is_in_newt,idx_in_newt] = ismember(raw_t{k},raw_t_new); %get indices of raw_t values falling within new chunk  %SLOW
            if raw_t{k}==0;
                is_in_newt=zeros(1,length(raw_t_new));
            end
            raw_new{k}=zeros(1,length(raw_t_new)); %initiate new raw vector
            idx_in_newt=idx_in_newt(idx_in_newt~=0); %remove zeros to get usable index
            if ~isempty(idx_in_newt)
                raw_new{k}(idx_in_newt)=raw{k}(is_in_newt); %assign data to new chunk %SLOW
            end
            raw_new{k}=int16(raw_new{k})';
            raw_new_idc{k}=[1:length(raw_new{k})];
            raw_empty{k}=~ismember(raw_new_idc{k},idx_in_newt);%keep idc of not recorded samples (remaining zeros) across files %% that should be done simpler
            if max(is_in_newt)==0
                lastblock(k)=0;
            else
                lastblock(k)=floor(max(find(is_in_newt))/1024); %get idx of last fully used block per file
            end
        end
         
    
    %translate nextchunk values into Blockranges
        lastblo=lastblock+BlockRange2Load(1,:);
        nextchunk_startblock=lastblo+1; 
        nextchunk_endblock=nextchunk_startblock+ChunkLength_blocks;
        
    %compare nextchunk_endblock to each files nLastBlockEach, prevent
    %loading attempts beyond end-of-files
    for k=1:nFiles
        if nextchunk_startblock(k)>=nLastBlockEach(k);
           nextchunk_startblock(k)=nLastBlockEach(k)-1; 
        end
        if nextchunk_endblock(k)>=nLastBlockEach(k);
           nextchunk_endblock(k)=nLastBlockEach(k);
        end
        
    end
  


    
    %% ----------------------------- Re-order the data ----------------------------------%    
    %Re-order the loaded channels in asceding order within each channel type
    indCH = find(strcmp(Header_ChanType,'CH'));
    [~,ind] = sort(Header_Chan(indCH));
    indCH = indCH(ind);
    
    if strcmp(AcqSystem, 'oephys')
        indAUX = find(strcmp(Header_ChanType,'AUX'));
        [~,ind] = sort(Header_Chan(indAUX));
        indAUX = indAUX(ind);
        indADC = find(strcmp(Header_ChanType,'ADC'));
        [~,ind] = sort(Header_Chan(indADC));
        indADC = indADC(ind);
        indALL = cat(2,indCH,indAUX,indADC);
        
    elseif strcmp(AcqSystem, 'ecube')
        indPAI = find(strcmp(Header_ChanType,'PAI'));
        [~,ind] = sort(Header_Chan(indPAI));
        indPAI = indPAI(ind);
        indPDI = find(strcmp(Header_ChanType,'PDI'));
        [~,ind] = sort(Header_Chan(indPDI));
        indPDI = indPDI(ind);
        indALL = cat(2,indCH,indPAI,indPDI);
        
    end %if strcmp(AcqSystem, 'oephys')
    
    raw_new = raw_new(indALL);
    LoadedFile = LoadedFile(indALL)';
    %sort also the original vectors to be used for mapping below
    Header_ChanType = Header_ChanType(indALL);
    Header_Chan     = Header_Chan(indALL);
    clear ind indCH indAUX indADC indPAI indPDI indALL
          
    
    
    %Check that ChanMapping has only unique indices  %% reintroduce later!
% %     if length(unique(ChanMapping))~=length(ChanMapping)
% %         msgbox('ChanMapping contains repeating channel indices!')
% %     end
    
    if any(ChanMapping<=0)
        error('ChanMapping contains negative or zero values!')
    end    
    
         
    
    %NEW----------------------------------------
    %Re-order channels based on the mapping map if provided
    if ~isempty(ChanMapping)
               
        
        if length(raw_new) == length(ChanMapping)
           
            %NEW: remap using actual channel indices from the file headers (equal to those from file names)
            indCH = find(strcmp(Header_ChanType,'CH'));
            %[~, indCH_remapped] = ismember(ChanMapping, Header_Chan(indCH));
            [~, indCH_remapped] = ismember(ChanMapping, (Header_Chan(indCH)+1));  %cx GS
            
            indMap = indCH_remapped;
            
            if any(indMap==0)
                error('ChanMapping contains indices of CH channels which are not present in the data!')
            end
            
        elseif length(raw_new) > length(ChanMapping)
            %if data have more channels (AUX or ADC) than in the mapping, just put them in the natural order at the end
            %NOTE: it is assumed that CH channels go always first.
            
            %NEW: remap using actual channel indices from the file headers (equal to those from file names)
            indCH = find(strcmp(Header_ChanType,'CH'));
            [~, indCH_remapped] = ismember(ChanMapping, (Header_Chan(indCH)+1));  %cx GS
            
            if strcmp(AcqSystem, 'oephys')
                indAUX = find(strcmp(Header_ChanType,'AUX'));
                indADC = find(strcmp(Header_ChanType,'ADC'));
                indMap = cat(1,indCH_remapped(:), indAUX(:), indADC(:));
                
            elseif strcmp(AcqSystem, 'ecube')
                indPAI = find(strcmp(Header_ChanType,'PAI'));
                indPDI = find(strcmp(Header_ChanType,'PDI'));
                indMap = cat(1,indCH_remapped(:), indPAI(:), indPDI(:));
                
            end %if strcmp(AcqSystem, 'oephys')
            
            if any(indMap==0)
                error('ChanMapping contains indices of CH channels which are not present in the data!')
            end
            
        end
        raw_new = raw_new(indMap);
        LoadedFile = LoadedFile(indMap);
        clear ind indCH indCH_remapped indAUX indADC indPAI indPDI indMap
        
    end %if ~isempty(ChanMapping)
          
    
    %% --------------------------------- Convert data format ---------------------------------------------%
    %Convert data: bits to mkV
    %NOTE: precision is kept as int16 even after conversion because we save to .dat file as int16 anyway
    %NOTE: AUX/ADC channels have different bitVolts values, which is not taken into account here.
    for k=1:nFiles
        raw_new{k} = raw_new{k} .* bitVolts;
    end
    
    %Convert timestamps: dat samples to mks (NOT DONE FOR NOW)
    % t = t / SamplingRate;    
    
    fprintf('DONE\n')
    
    
    %% ------------------------------ Save/append data (mkV) to .dat file -----------------------------------% 
    fprintf('Saving data chunk-%d of %d (1024-samples, %d channels) to %s ...', n, nChunks, nFiles, FileOut)  
    if n==1
        fid_out = fopen(FileOut,'w');
    else
        fid_out = fopen(FileOut,'a');
    end    
    fwrite(fid_out, cell2mat(raw_new)','int16');
    fclose(fid_out);
    fprintf('DONE\n') 
    
    clear raw raw_t raw_new raw_t_new t LoadedFile gaps Header_ChanType Header_Chan BlockRange2Load
    %------------------------ END of Loading section ----------------------------------------------------% 
    
    if sum(nextchunk_endblock==nLastBlockEach)==length(nLastBlockEach); %stop when all data blocks from all files have been read
        finished=finished+0.5; %initiate one last round if all files are due to get their last blocks loaded
    end
    
end %loop across chunks


fprintf('-------------------------------------------------------------------------------------------------------\n')
fprintf('Order of channels in %s after mapping: \n', FileOut);
%disp(LoadedFile)
fprintf('-------------------------------------------------------------------------------------------------------\n')


%% ---------------- Create an info file: [nChan SamplingRate nSamples StartTime EndTime] -----------------%
%NOTE: if the data contained time gaps, a new time vector without gaps is created and 
%StartTime/ EndTime are taken from this new time vector. 
[~, t] = load_open_ephys_data_blocks(FileList{1}, 'unscaledInt16', [1 2]);
OverallStartTimestamp = t(1);
FileOut_info = [FileOut '.info'];
fprintf('Saving [nChan  SamplingRate_Hz  nSamples  StartTime  EndTime  IfGapCorrected] into a file %s ...', FileOut_info)
info = [ SamplingRate  nBlocks*1024  OverallStartTimestamp OverallStartTimestamp+nBlocks*1024-1  ]; 
dlmwrite(FileOut_info, info, 'delimiter','\t','precision','%.0f');
fprintf('DONE\n')



return









